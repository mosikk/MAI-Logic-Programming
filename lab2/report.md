## Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Моисеенков И.П.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       5       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Программы на декларативных языках программирования состоят из набора фактов и правил, а работа таких языков основывается на сопоставлении имеющихся фактов. Такой же механизм используется и человеком при решении логических задач. А значит можно написать программу на языке Prolog, которая сможет решить логическую задачу, используя данные ей факты.

Для решения логических задач на декларативных языках существует несколько методов: метод генерации и проверки, метод подробного описания всех фактов и многие другие. В решении таких задач часто применяются отчесения и отрицания.

## Задание

Дина, Соня, Коля, Рома и Миша учатся в институте. Их фамилии Бойченко, Карпенко, Лысенко, Савченко и Шевченко. Мать Ромы умерла. Родители Дины никогда не встречались с родителями Коли. Студенты Шевченко и Бойченко играют в одной баскетбольной команде. Услышав, что родители Карпенко собираются поехать за город, мать Шевченко пришла к матери Карпенко и попросила, чтобы та отпустила своего сына к ним на вечер, но оказалось, что отец Коли уже договорился с родителями Карпенко и пригласил их сына к Коле. Отец и мать Лысенко хорошие друзья родителей Бойченко. Все четверо очень довольны, что их дети собираются пожениться. Установите имя и фамилию каждого из молодых людей и девушек.

## Принцип решения

За основу для решения своей задачи я взял метод генерации и проверки. Он основывается на том, что в программе генерируются все возможные сопоставления имен и фамилий, а затем по введенным фактам идёт поиск противоречий. Если противоречия не найдены, значит сгенерированная перестановка - решение задачи.

Первым делом я выделил из условия задачи ключевые факты и начал описывать их в виде структуры `data(permutation, fact, args, T/F)`, где permutation - сгенерированная перестановка, fact - описываемый факт, args - аргументы для факта, T/F - true или false. Эти факты приведены ниже:

* У Ромы нет матери
* У Шевченко и Карпенко есть мать
* У Лысенко и Бойченко есть мать

В качестве аргумента для факта mother выступает имя (или фамилия) студента. Значение true означает, что у человека есть мама.

```
% mother <=> argument has mother
data([_, _, _, Roma, _], mother, [Roma], false).
data(_, mother, [shevchenko], true).
data(_, mother, [karpenko], true).
data(_, mother, [lysenko], true).
data(_, mother, [boychenko], true).
```

* Родители Дины не знакомы с родителями Коли
* Родители Шевченко знакомы с родителями Карпенко
* Родители Лысенко знакомы с родителями Бойченко

В качестве аргумента для факта meet выступает пара двух семей, знакомых друг с другом. Значение true означает, что семьи знакомы друг с другом.

```
% meet <=> arg1 met arg2
data(_, meet, [shevchenko, karpenko], true).
data(_, meet, [karpenko, shevchenko], true).

data(_, meet, [lysenko, boychenko], true).
data(_, meet, [boychenko, lysenko], true).

data([Dina, _, Kolya, _, _], meet, [Dina, Kolya], false).
data([Dina, _, Kolya, _, _], meet, [Kolya, Dina], false).
```

* Карпенко - мальчик

В качестве аргумента для факта boy выступает один человек. Значение true означает, что человек мужского пола.

```
% boy <=> arg is a boy
data(_, boy, [karpenko], true).
data([Dina, _, _, _, _], boy, [Dina], false).
data([_, Sonya, _, _, _], boy, [Sonya], false).
data([_, _, Kolya, _, _], boy, [Kolya], true).
data([_, _, _, Roma, _], boy, [Roma], true).
data([_, _, _, _, Misha], boy, [Misha], true).
```

* Шевченко и Бойченко одного пола
* Лысенко и Бойченко разного пола

Для проверки данных фактов мной был реализован предикат `same_gender(Permutation, X, Y)`, в котором сравнивался пол человека X и человека Y. Предикат возвращает истину, если X и Y одного пола. Пол устанавливается на основе фактов, составленных ранее. В конце предиката используется отсечение, чтобы избежать ненужной рекурсии.

```
% same_gender(Variant, Person1, Person2) -> true if X has the same gender as Y
same_gender(Variant, X, Y) :- data(Variant, boy, [X], TF), data(Variant, boy, [Y], FT), TF == FT, !.
```

* Карпенко - не Коля.

Проверка этого факта будет описана в функции solve.


#### Предикат solve

`solve(Dina, Sonya, Kolya, Roma, Misha)` - предикат, задача которого - решить задачу. При помощи предиката `permute` генерируются все возможные сопоставления имен и фамилий. Для каждой генерации проверяются следующие факты:
- Фамилия Коли - не Карпенко
- Шевченко и Бойченко одного пола
- Лысенко и Бойченко разного пола
- Для данной перестановки не найдено противоречий с описанными ранее фактами.

Поиск противоречий производится предикатом `contradiction(Variant)`, который сопоставляет значения true и false из фактов. В случае обнаружения логического несоответствия предикат возвращает значение "ложь".

```
% searching for contradictions in generated variant
contradiction(Variant) :- data(Variant, Fact, Arg, TF), logical_not(TF, FT), data(Variant, Fact, Arg, FT).

% logical inversion
logical_not(true, false).
logical_not(false, true).

% predicate to solve the problem
solve(Dina, Sonya, Kolya, Roma, Misha) :- 
    permute([Dina, Sonya, Kolya, Roma, Misha], [boychenko, karpenko, lysenko, savchenko, shevchenko]),
    Kolya \= karpenko,
    same_gender([Dina, Sonya, Kolya, Roma, Misha], shevchenko, boychenko),
    not(same_gender([Dina, Sonya, Kolya, Roma, Misha], lysenko, boychenko)),
    not(contradiction([Dina, Sonya, Kolya, Roma, Misha])), !.

```

В конце предиката solve используется отсечение из-за единственности решения. Если противоречий в текущей перестановке не найдено, значит это единственное возможное решение: дальше проверять нет смысла. Зацикливание в программе не происходит.

Результат работы предиката:
```
2 ?- solve(Dina, Sonya, Kolya, Roma, Misha).
Dina = shevchenko,
Sonya = boychenko,
Kolya = lysenko,
Roma = savchenko,
Misha = karpenko.
```

Ответ Пролога совпадает с моим ответом, следовательно программа работает корректно. Ответ непротиворечивный.

При проверке работы предиката без отсечения дополнительных решений найдено не было.

Сложность алгоритма работы программы - O(n!), т.к предикат permute в худшем случае может сгенерировать все возможные перестановки, количество которых для списка длины n равняется n!.

## Выводы

Выполнив данную лабораторную работу, я убедился, что механизмы логического программирования могут справиться с решением логической задачи, которая может оказаться непосильной некоторым людям. Решение таких задач на Прологе вряд ли найдёт какое-либо практическое применение, однако данная работа демонстрирует, насколько обширным может быть дерево решений декларативного языка. Пролог может решить сколь угодно объёмную задачу, и гарантируется, что он рассмотрит абсолютно все введённые программистом факты и правила, выполнит перебор абсолютно всех вариантов (если не используются отсечения).

Однако стоит учитывать, что решение логических задач - дело не быстрое. Сложность таких алгоритмов может быть порядка n! из-за проверки всех перестановок и глубокой рекурсии. Но на небольшом объёме данных Пролог все равно сможет найти решение за доли секунды. А логические задачи с огромным количеством данных, пожалуй, никто решать не будет.



