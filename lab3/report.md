## Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Моисеенков И.П.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Алгоритмы поиска в графах могут использоваться не только для привычного поиска маршрутов. Если в качестве вершин графа будут выступать состояния какой-либо задачи, а в качестве рёбер - возможные переходы между этими состояниями, то при помощи стандартных алгоритмов поиска можно найти решение данной задачи в полученном графе. Таким методом можно решать не только простейшие логические задачи, но и более серьёзные, например, логистические.

Основной принцип работы Пролога - поиск всевозможных соответствий между описанными фактами и правилами. Пролог гарантированно рассмотрит все варианты ответов. Из этого следует, что данный язык программирования можно использовать для поиска в некотором пространстве состояний. Для этого требуется описать один из алгоритмов поиска (самый простой - поиск в глубину, так как сам Пролог использует его), описать и формализовать состояния и переходы между ними.

В данной лабораторной работе рассматриваются алгоритмы поиска в пространстве состояний. При помощи этого метода решается несложная логическая задача.

## Задание

Вдоль доски расположено 7 лунок, в которых лежат 3 белых и 3 чёрных шара. Передивинуть чёрные шары на место белых, а белые - на место чёрных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром.

```['w', 'w', 'w', '_', 'b', 'b', 'b'] ---> ['b', 'b', 'b', '_', 'w', 'w', 'w']```

## Принцип решения

В качестве состояния в этой задаче будет использоваться текущее положение шаров на доске.

Возможные переходы:
* Передвинуть белый шар вправо в свободную лунку
* Передвинуть чёрный шар влево в свободную лунку
* Передвинуть чёрный шар влево в свободную лунку непосредственно за белым шаром
* Передвинуть белый шар вправо в свободную лунку непосредственно за чёрным шаром

```
% describing all possible moves
move(Cur, Next) :- append(Head, ['w', '_' | Tail], Cur), append(Head, ['_', 'w' | Tail], Next).
move(Cur, Next) :- append(Head, ['_', 'b' | Tail], Cur), append(Head, ['b', '_' | Tail], Next).
move(Cur, Next) :- append(Head, ['_', 'w', 'b' | Tail], Cur), append(Head, ['b', 'w', '_' | Tail], Next).
move(Cur, Next) :- append(Head, ['w', 'b', '_' | Tail], Cur), append(Head, ['_', 'b', 'w' | Tail], Next).
```

В данной работе я использовал три алгоритма поиска: поиск в глубину, поиск в ширину, поиск с итерационным заглублением.

Поиск в глубину работает так же, как и сам Пролог. Мы будем пытаться максимально углубляться, но в случае отсутствия дальнейших переходов будем откатываться на предыдущий шаг и пробовать углубляться в другом направлении.

```
 % Depth First Search
dfs(Start, Finish) :- path_dfs([Start], Finish, Path), print_path(Path).

% found the result
path_dfs([Finish | Tail], Finish, [Finish | Tail]).

% prolonging Cur_Path and continue our search
path_dfs(Cur_Path, Finish, Res_Path) :- prolong(Cur_Path, Next_Path), path_dfs(Next_Path, Finish, Res_Path).
```

Поиск в ширину сначала ищет все состояния, в которые можно перейти из текущего. Далее найденные состояния будут рассматриваться по очереди: для каждого состояния вновь будут искаться все новые состояния, в которых мы можем оказаться. Все новые состояния помещаются в конец очереди. Так постепенно будем обрабатывать очередь, пока не найдем ответ или пока она не опустеет.

```
% Breadth First Search
bfs(Start, Finish) :- path_bfs([[Start]], Finish, Path), print_path(Path).

% found the result
path_bfs([[Finish | Tail] | _], Finish, [Finish | Tail]).

% prolonging Cur_Path in all possible ways
path_bfs([Cur_Path | Cur_Queue], Finish, Path) :- findall(New_Path, prolong(Cur_Path, New_Path), List),
                                                append(Cur_Queue, List, New_Queue), !,
                                                path_bfs(New_Queue, Finish, Path).

% if Cur_Path can't be prolonged, we should remove it
path_bfs([ _ | Queue], Finish, Path) :- path_bfs(Queue, Finish, Path).
```

Принцип работы поиска с итерационным заглублением схож с поиском в глубину. Различие в том, что поиск с итерационным заглублением не идет сразу вглудь дерева. Сначала он ищет ответ среди всех путей длины 1, затем среди всех путей длины 2 и т.д. Таким образом, данный алгоритм всегда найдёт кратчайший первый путь, что не гарантируется в случае поиска в ширину и в глубину.

```
% Search with iterative deepening
iter(Start, Finish) :- for(Cur_Depth, 1, 20), iter(Start, Finish, Path, Cur_Depth), print_path(Path).

% searching for the path with length = DepthLimit
iter(Start, Finish, Path, DepthLimit) :- path_iter([Start], Finish, Path, DepthLimit).

% found the result at the depth of current DepthLimit
path_iter([Finish | Path], Finish, [Finish | Path], 0).

% prolonging Cur_Path and continue our search
path_iter(Cur_Path, Finish, Path, Depth) :- Depth > 0, prolong(Cur_Path, New_Path),
                                                        New_Depth is Depth - 1,
                                                        path_iter(New_Path, Finish, Path, New_Depth).

```

Все алгоритмы поиска использовали в своей работе предикат prolong. Данный предикат ищет все возможные переходы и проверяет, не было ли уже такого состояния в текущих переходах.

```
% prolonging our path to New_Pos
prolong([Cur_Pos | Tail], [New_Pos, Cur_Pos | Tail]) :- move(Cur_Pos, New_Pos), 
                                                    not(member(New_Pos, [Cur_Pos | Tail])).
```

## Результаты

```
2 ?- dfs(['w', 'w', 'w', '_', 'b', 'b', 'b'], ['b', 'b', 'b', '_', 'w', 'w', 'w']).
[w,w,w,_,b,b,b]
[w,w,_,w,b,b,b]
[w,w,b,w,_,b,b]
[w,w,b,w,b,_,b]
[w,w,b,_,b,w,b]
[w,_,b,w,b,w,b]
[_,w,b,w,b,w,b]
[b,w,_,w,b,w,b]
[b,w,b,w,_,w,b]
[b,w,b,w,b,w,_]
[b,w,b,w,b,_,w]
[b,w,b,_,b,w,w]
[b,_,b,w,b,w,w]
[b,b,_,w,b,w,w]
[b,b,b,w,_,w,w]
[b,b,b,_,w,w,w]
true ;
[w,w,w,_,b,b,b]
[w,w,w,b,_,b,b]
[w,w,_,b,w,b,b]
[w,_,w,b,w,b,b]
[w,b,w,_,w,b,b]
[w,b,w,b,w,_,b]
[w,b,w,b,w,b,_]
[w,b,w,b,_,b,w]
[w,b,_,b,w,b,w]
[_,b,w,b,w,b,w]
[b,_,w,b,w,b,w]
[b,b,w,_,w,b,w]
[b,b,w,b,w,_,w]
[b,b,w,b,_,w,w]
[b,b,_,b,w,w,w]
[b,b,b,_,w,w,w]
true ;
false.

3 ?- bfs(['w', 'w', 'w', '_', 'b', 'b', 'b'], ['b', 'b', 'b', '_', 'w', 'w', 'w']).
[w,w,w,_,b,b,b]
[w,w,_,w,b,b,b]
[w,w,b,w,_,b,b]
[w,w,b,w,b,_,b]
[w,w,b,_,b,w,b]
[w,_,b,w,b,w,b]
[_,w,b,w,b,w,b]
[b,w,_,w,b,w,b]
[b,w,b,w,_,w,b]
[b,w,b,w,b,w,_]
[b,w,b,w,b,_,w]
[b,w,b,_,b,w,w]
[b,_,b,w,b,w,w]
[b,b,_,w,b,w,w]
[b,b,b,w,_,w,w]
[b,b,b,_,w,w,w]
true ;
[w,w,w,_,b,b,b]
[w,w,w,b,_,b,b]
[w,w,_,b,w,b,b]
[w,_,w,b,w,b,b]
[w,b,w,_,w,b,b]
[w,b,w,b,w,_,b]
[w,b,w,b,w,b,_]
[w,b,w,b,_,b,w]
[w,b,_,b,w,b,w]
[_,b,w,b,w,b,w]
[b,_,w,b,w,b,w]
[b,b,w,_,w,b,w]
[b,b,w,b,w,_,w]
[b,b,w,b,_,w,w]
[b,b,_,b,w,w,w]
[b,b,b,_,w,w,w]
true ;
false.

4 ?- iter(['w', 'w', 'w', '_', 'b', 'b', 'b'], ['b', 'b', 'b', '_', 'w', 'w', 'w']).
[w,w,w,_,b,b,b]
[w,w,_,w,b,b,b]
[w,w,b,w,_,b,b]
[w,w,b,w,b,_,b]
[w,w,b,_,b,w,b]
[w,_,b,w,b,w,b]
[_,w,b,w,b,w,b]
[b,w,_,w,b,w,b]
[b,w,b,w,_,w,b]
[b,w,b,w,b,w,_]
[b,w,b,w,b,_,w]
[b,w,b,_,b,w,w]
[b,_,b,w,b,w,w]
[b,b,_,w,b,w,w]
[b,b,b,w,_,w,w]
[b,b,b,_,w,w,w]
true ;
[w,w,w,_,b,b,b]
[w,w,w,b,_,b,b]
[w,w,_,b,w,b,b]
[w,_,w,b,w,b,b]
[w,b,w,_,w,b,b]
[w,b,w,b,w,_,b]
[w,b,w,b,w,b,_]
[w,b,w,b,_,b,w]
[w,b,_,b,w,b,w]
[_,b,w,b,w,b,w]
[b,_,w,b,w,b,w]
[b,b,w,_,w,b,w]
[b,b,w,b,w,_,w]
[b,b,w,b,_,w,w]
[b,b,_,b,w,w,w]
[b,b,b,_,w,w,w]
true ;
false.
```

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|----------------|
| В глубину       |             16                 |      0.012     |
| В ширину        |             16                 |      0.020     |
| ID              |             16                 |      0.010     |

## Выводы

В данной лабораторной работе я изучил алгоритмы поиска и их реализацию на языке Пролог. Я сравнил работу следующих алгоритмов: поиск в ширину, поиск в глубину, поиск с итерационным заглублением. Выяснилось, что самым быстрым оказался поиск с итерационным заглублением. Чуть дольше работал поиск в глубину. Поиск в ширину работал в два раза дольше итерационного поиска.

Ещё один недостаток поиска в ширину - достаточно большое потребление памяти. Этот алгоритм требует O(b^l) дополнительной памяти, где b - коэффициент ветвления, l - количество шагов для решения задачи. Поиск в глубину и поиск с итеративным заглублением требуют всего лишь O(l) памяти.

Но у поиска в ширину есть и свои плюсы: он может находить пути с циклами, первый найденный путь - кратчайший, а время нахождения кратчайшего пути невелико (к сожалению, на примере данной задаче это не удалось увидеть, так как все решения имеют одинаковую "длину").

Изначально мне казалось, что алгоритм с итерационным заглублением будет медленным и неэффективным - он много раз проходит по одним и тем же путям. Однако данный алгоритм оказался самым оптимальным для использования. Он сочетает в себе лучшие стороны поиска в глубину (время работы, затраченная память) и поиска в ширину (первый найденный путь - кратчайший).




