# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Моисеенков И.П.
## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

 remove(Head, [Head|Tail], ListNew) =>  ListNew=Tail ?

## Введение

В Прологе, как и во многих других языках программирования, можно хранить не только отдельные элементы, но и какие-то наборы различных элементов. Для этого используется такая структура данных как список. Списки в Прологе отличаются от списков, например, в языке Python, к которым все так привыкли. Здесь список - это либо пустой элемент; либо один элемент, называемый головой, и присоединенный список - хвост. Это рекурсивная структура данных с последовательным доступом. Прологовский список это скорее некий гибрид очереди и линейного списка. В рамках данной лабораторной работы мне предложено более подробно разобраться с этой структурой данных в Прологе и научиться работать с ней.

## Задание 1.0: Реализация стандартных предикатов

* `length1(X, Y)` - определение длины (Y) списка X.

Примеры использования:
```
2 ?- length1([1,2,3], X).
X = 3.

3 ?- length1([], X).
X = 0.

4 ?- length1([1,1,1,1,1,1,1,1], X).
X = 8.

5 ?- length1([1,2,3], 3).
true.

6 ?- length1([1,2], 3).
false.
```

Реализация:
```
% length1(list, list_length).
length1([], 0).
length1([_|Tail], Length) :- length(Tail, Length1), Length is Length1 + 1.
```

В SWI Prolog имеется встроенный предикат length, поэтому мной был реализован аналогичный предикат length1. Если встречается пустой список, то его длина, очевидно, равна нулю. В противном случае отсекается голова списка, рекурсивно определяется длина нового получившегося списка и к результату прибавляется единица.


* `member1(X, Y)` - определяет принадлежность элемента Х списку Y.

Примеры использования:
```
7 ?- member1(1, [1,2,3,4]).
true ;
false.

8 ?- member1(2, [1,5,1,3]).
false.

9 ?- member1(X, [1,2,3]).
X = 1 ;
X = 2 ;
X = 3 ;
false.
```

Реализация:
```
% member1(element, list).
member1(Element, [Element|_]).
member1(Element, [_|Tail]) :- member1(Element, Tail).
```

В SWI Prolog имеется встроенный предикат member, поэтому мной был реализован аналогичный предикат member1. Очевидно, что если список начинается с искомого элемента, то элемент принадлежит списку. В противном случае необходимо отсечь голову списка и рекурсивно проверить наличие элемента в новом получившемся списке.


* `append1(X, Y, Z)` - конкатенация списков X и Y в результирующий список Z.

Примеры использования:
```
10 ?- append1([1,2,3], [3,2,1], X).
X = [1, 2, 3, 3, 2, 1].

11 ?- append1([], [], X). 
X = [].

12 ?- append1([1,1],[1,1,1], X).
X = [1, 1, 1, 1, 1].

13 ?- append1(X, Y, [1,2,3]).
X = [],
Y = [1, 2, 3] ;
X = [1],
Y = [2, 3] ;
X = [1, 2],
Y = [3] ;
X = [1, 2, 3],
Y = [] ;
false.
```

Реализация:
```
% append1(list1, list2, list1 + list2).
append1([], List, List).
append1([Head|Tail], List2, [Head|ResList2]) :- append1(Tail, List2, ResList2).
```

В SWI Prolog имеется встроенный предикат append, поэтому мной был реализован аналогичный предикат append1. Если нужно выполнить конкатенацию пустого списка и какого-то другого списка, то результатом, очевидно, будет второй список. Иначе отделяем голову первого списка, добавляем ее в результирующий список. Хвост результирующего списка назовём Z. Далее рекурсивно выполняем конкатенацию первого списка без головы и второго списка, полученный результат подставляем на место списка Z.


* `remove(X, Y, Z)` - удаление элемента X из списка Y, копирование полученного списка в Z.

Примеры использования:
```
14 ?- remove(1, [1,2,3], X).
X = [2, 3] ;
false.

15 ?- remove(1, [1,2,1,3,1,4,1], X).
X = [2, 1, 3, 1, 4, 1] ;
X = [1, 2, 3, 1, 4, 1] ;
X = [1, 2, 1, 3, 4, 1] ;
X = [1, 2, 1, 3, 1, 4] ;
false.

16 ?- remove(1, [2,3,4], X).
false.
```

Реализация:
```
% remove(element, list, list_without_element).
remove(Element, [Element|Tail], Tail).
remove(Element, [Head|Tail], [Head|Tail2]) :- remove(Element, Tail, Tail2).
```

Если удаляемый элемент находится в голове списка, то ответ - список с отсечённой головой. Иначе отсекаем голову Head списка и пытаемся удалить элемент из хвоста Tail. Результатом будет список, состоящий из отсечённой головы Head и списка Tail без элемента Element (список Tail1). Если удаляемого элемента в списке не окажется, то Пролог выдаст результат "false".


* `permute(X, Y)` - совершить перестановку (Y) элементов списка X.

Примеры использования:
```
2 ?- permute([1,2,3], X).
X = [1, 2, 3] ;
X = [1, 3, 2] ;
X = [2, 1, 3] ;
X = [2, 3, 1] ;
X = [3, 1, 2] ;
X = [3, 2, 1] ;
false.

3 ?- permute([1,2,3,4], [4,1,2,3]).
true ;
false.

4 ?- permute([1,2,3,4], [1,5,2,3]).
false.

5 ?- permute([1,2], [1,2,3,4,5]).
false.
```

Реализация:
```
% permute(list, permutation).
permute([], []).
permute(List, [Head|Tail]) :- remove(Head, List, Result), permute(Result, Tail).
```

Определим крайний случай рекурсии: перестановка пустого списка есть пустой список. Если список непустой, то необходимо удалить из него один элемент и рекурсивно выполнить перестановку полученного списка. Удалённый элемент добавить в голову новой перестановки.


* `sublist(X, Y)` - проверка, является ли X подсписком списка Y.

Примеры использования:
```
6 ?- sublist([1,2], [3,4,1,2,6]).
true ;
false.

7 ?- sublist([1,2,3], [1,4,2,3]).
false.

8 ?- sublist(X, [1,2,3,4]).
X = [] ;
X = [1] ;
X = [1, 2] ;
X = [1, 2, 3] ;
X = [1, 2, 3, 4] ;
X = [] ;
X = [2] ;
X = [2, 3] ;
X = [2, 3, 4] ;
X = [] ;
X = [3] ;
X = [3, 4] ;
X = [] ;
X = [4] ;
X = [] ;
false.
```

Реализация:
```
% sublist(sublist, list).
sublist(Sublist, List) :- append(_, List1, List), append(Sublist, _, List1).
```

Список Sublist является подсписком списка List, если существует такой подсписок List1, из начала которого можно выделить подсписок Sublist.

## Задание 1.1: Предикат обработки списка - удаление последнего элемента

* `remove_last(X, Y)` - удаление последнего элемента списка Х. Результат - список Y. Реализован при помощи стандартных предикатов обработки списка.

Примеры использования:
```
2 ?- remove_last([1,2,3], X).
X = [1, 2] ;
false.

3 ?- remove_last([1,1,1], X).
X = [1, 1] ;
false.

4 ?- remove_last([1], X).
X = [] ;
false.

5 ?- remove_last([], X).
false.

6 ?- remove_last([1,2,3], [1,2]).
true.

7 ?- remove_last([1,2,3], [1,2,3]).  
false.
```

Реализация:
```
% remove_last(initial_list, list_without_last_element).
remove_last(List, ListNew) :- append1(ListNew, [_], List).
```

Чтобы удалить последний элемент списка List, необходимо разбить его на два списка при помощи предиката конкатенации append так, чтобы второй список состоял только из одного элемента. Тогда первый список разбиения включает в себя все элементы кроме последнего, что и является искомым результатом.


* `remove_last1(X, Y)` - удаление последнего элемента списка Х. Результат - список Y. Реализован без применения стандартных предикатов обработки списка.

Примеры использования:
```
8 ?- remove_last1([1,2,3,4], X).
X = [1, 2, 3] ;
false.

9 ?- remove_last1([1,1,1,1], X).
X = [1, 1, 1] ;
false.

10 ?- remove_last1([1], X).
X = [] ;
false.

11 ?- remove_last1([], X).  
false.

12 ?- remove_last1([1, 2, 3], [1, 2]). 
true ;
false.

13 ?- remove_last1([1, 2, 3], [1]).    
false.
```

Реализация:
```
remove_last1([_], []).
remove_last1([Head|Tail], [Head|Res1]) :- remove_last1(Tail, Res1).
```

Опишем условие окончание рекурсии: если мы хотим удалить последний элемент списка, состоящего из одного элемента, то получим пустой список. В противном случае, нам нужно отделить голову и удалить последний элемент из полученного списка. Удалённая голова становится головой итогового списка.

* Совместное использование предикатов - проверка на палиндром.
`palindrome(X).` - проверяет, является ли список X палиндромом.

Примеры использования:
```
12 ?- palindrome([1,2,1]).
true ;
false.

13 ?- palindrome([1,2,2]). 
false.

14 ?- palindrome([1,2,3,3,2,1]).
true ;
false.

15 ?- palindrome([1,2,3,2,1]).   
true ;
false.
```

Реализация:
```
% palindrome(list).
palindrome([]).
palindrome([_]).
palindrome([Head|Tail]) :- remove_last(Tail, TailNew), 
                           append(TailNew, [Element], Tail), 
                           Element == Head, palindrome(TailNew).
```

Определим конечный случай рекурсии: пустой список и список из одного элемента - палиндромы. В противном случае, необходимо разделить список на голову Head и хвост Tail и произвести удаление последнего элемента из хвоста. Хвост Tail с удалённым последним элементом назовём TailNew. Затем нужно проверить, можно ли произвести конкатенацию списка TailNew со списком, состоящим из одного элемента, так, чтобы в результате получился исходный список Tail, а новый элемент был равен голове Head списка. Если можно, то первый и последний элементы списка совпадают и необходимо рекурсивно проверить на палиндром список без первого и без последнего элемента (хранится в TailNew).

## Задание 1.2: Предикат обработки числового списка - подсчёт количества чётных элементов

* `count_evens(X, N)` - подсчёт количества чётных элементов в списке X. Результат хранится в переменной N. Реализован без использования стандартных предикатов.

Примеры использования:
```
2 ?- count_evens([1,2,3,4,5], X).
X = 2.

3 ?- count_evens([1], X).         
X = 0.

4 ?- count_evens([2, 2, 2], X). 
X = 3.

5 ?- count_evens([], X).        
X = 0.

6 ?- count_evens([1, 2, 4], 2).  
true.

7 ?- count_evens([1, 2, 4], 3). 
false.
```

Реализация:
```
% count_evens(list, number_of_even_numbers).
count_evens([], 0).
count_evens([Head|Tail], Number) :- count_evens(Tail, Number1), Number is Number1 + (Head + 1) mod 2.
```

Опишем крайний случай рекурсии: количество чётных чисел в пустом списке всегда равно нулю. Если список не пустой, то отделяем голову Head от списка и рекурсивно считаем количество четных чисел в хвосте. К полученному результату прибавляем результат выражения (Head + 1) mod 2. Результат этого выражения равен 1, если Head - чётное число, и 0 в противном случае. Таким образом мы подсчитаем количество всех чётных элементов списка.

* `count_evens1(X, N)` - подсчёт количества чётных элементов в списке X. Результат хранится в переменной N. Реализован с использованием стандартных предикатов для обработки списка.

Примеры использования:
```
2 ?- count_evens1([1,2,3,4,5], X).
X = 2 ;
false.

3 ?- count_evens1([1,2,3,4,5,6], X).  
X = 3 ;
false.

4 ?- count_evens1([1,3,5,7], X).     
X = 0 ;
false.

5 ?- count_evens1([1,3,5,7], 2). 
false.

6 ?- count_evens1([2, 4, 5], 2). 
true ;
false.

7 ?- count_evens1([2, 2, 2], X).  
X = 3 ;
X = 3 ;
X = 3 ;
X = 3 ;
X = 3 ;
X = 3 ;
false.
```

Реализация:
```
count_evens1([], 0).
count_evens1([Head|Tail], Number) :- remove(Head, [Head|Tail], ListNew), 
                                     count_evens1(ListNew, Number1), 
                                     Number is Number1 + (Head + 1) mod 2.
```

Крайний случай рекурсии аналогичен предыдущей реализации. Если встретился непустой список, то отделяем его голову, удаляем ее из списка и рекурсивно считаем количество чётных чисел получившегося списка. К этому количеству прибавляем результат выражения (Head + 1) mod 2, его смысл описан выше.
Недостаток данной реализации: из-за того, что предикат remove работает рекурсивно, то при обработке списка, состоящего из K одинаковых чётных чисел, результат будет выведен K! раз.

## Задание 2: Реляционное представление данных

Реляционное представление данных порой оказывается очень удобным для использования. Достоинствами реляционного представления является простота организации базы данных, наличие строгих правил проектирования и полная независимость данных. Однако в качестве недостатков можно выделить относительно большой объём занимаемой памяти.

В моем варианте использовалось представление данных в виде фактов следующей структуры:

```
grade(группа, фамилия, предмет, оценка).
```

Данное представление легко обрабатывать как человеку, так и компьютеру, но оно намного объёмнее остальных вариантов представления данных.

Ниже будут реализованы предикаты для выполнения задания 2.

* `subjects(X)` - возвращает список всех предметов Х.

Пример использования:
```
3 ?- subjects(X).
X = ['Английский язык', 'Информатика', 'Логическое программирование', 'Математический анализ', 'Психология', 'Функциональное программирование'].
```

Реализация:
```
% list of subjects
subjects(List) :- setof(Subject, A^B^C^grade(A, B, Subject, C), List).
```

Ищем все предметы, которые встречаются в базе данных. Номер группы, фамилия студента и оценка за экзамен не конкретизируются.

* `sum(L, X)` -  подсчёт суммы элементов списка L. Результат записывается в переменную X. Это вспомогательный предикат для выполнения задания.

Примеры использования:
```
2 ?- sum([1,2,3], X).
X = 6.

3 ?- sum([10,20,100], X).
X = 130.

4 ?- sum([], X).
X = 0.

5 ?- sum([1,1,1], 2).
false.

6 ?- sum([1,1,1], 3). 
true.
```

Реализация:
```
% sum(list, sum_of_elements).
sum([], 0).
sum([Head|Tail], Sum) :- sum(Tail, Sum1), Sum is Sum1 + Head.
```

Крайний случай рекурсии: сумма элементов пустого списка равна нулю. Если встретился непустой список, то отделяем голову, рекурсивно считаем сумму элементов хвоста списка и к полученному результату прибавляем величину отделённой головы.

* `average(L, X).` - поиск среднего значения элементов списка L. Результат помещается в переменную X.

Примеры использования:
```
2 ?- average([2,4,6], X).
X = 4.

3 ?- average([1,1,1], X).
X = 1.

4 ?- average([5,6,2,1], X).
X = 3.5.

5 ?- average([5,3,2], X).
X = 3.3333333333333335.

6 ?- average([1,2,3], 2).
true.

7 ?- average([1,2,3], 3). 
false.
```

Реализация:
```
% average(list, average_value_of_elements).
average(List, Average) :- sum(List, Sum), length(List, Length), Average is Sum / Length.
```

Среднее значение элементов списка есть сумма всех значений элементов, поделённое на их количество (т.е. на длину списка).

* Вариант 2. Задание 1. Напечатать средний балл для каждого предмета

`get_average_grade(S, N)` - получить средний балл N для предмета S.

Примеры использования:
```
8 ?- get_average_grade('Математический анализ', X).
X = 3.892857142857143.

9 ?- get_average_grade('Психология', X).            
X = 3.9285714285714284.

10 ?- get_average_grade('Функциональное программирование', X). 
X = 3.9642857142857144.

11 ?- get_average_grade('Функциональное программирование', 2). 
false.
```

Реализация:
```
% get_average_grade(subject, average_grade). - counts average grade for a subject
get_average_grade(Subject, Number) :- findall(Mark, grade(_, _, Subject, Mark), List), 
                                      average(List, Number).

```

При помощи предиката findall получаем список всех оценок, полученных студентами по предмету Subject. Затем ищем среднее значение найденного списка.

* `print_average_grades(Subj, Avrg)`- выводит на экран среднюю оценку для каждого предмета.

Пример использования:
```
4 ?- print_average_grades(X, Y).
X = 'Английский язык',
Y = 3.75 ;
X = 'Информатика',
Y = 3.9285714285714284 ;
X = 'Логическое программирование',
Y = 3.9642857142857144 ;
X = 'Математический анализ',
Y = 3.892857142857143 ;
X = 'Психология',
Y = 3.9285714285714284 ;
X = 'Функциональное программирование',
Y = 3.9642857142857144.
```

Реализация:
```
% print average grades for every subject
print_average_grades(Subject, Average) :- subjects(Subjects), member(Subject, Subjects), get_average_grade(Subject, Average).
```

Вызываем функцию get_average_grade для всех предметов из списка.

* Вариант 2. Задание 2. Для каждой группы, найти количество не сдавших студентов

`print_failed_exam(G, N)` - найти и вывести количество студентов группы G, которые не сдали как минимум один предмет.

Примеры использования:
```
7 ?- print_failed_exam(X, Y).
X = 101,
Y = 2 ;
X = 102,
Y = 5 ;
X = 103,
Y = 3 ;
X = 104,
Y = 2.
```

Реализация:
```
% failed_exam(group, number_of_students_that_didn't_pass_exams).
print_failed_exam(Group, Number) :- setof(Student, A^grade(Group, Student, A, 2), List), length(List, Number).
```

При помощи предиката setof ищем список всех студентов, у которых стоит двойка за какой-либо предмет. Искомое количество - длина полученного списка.

* Вариант 2. Задание 3. Найти количество не сдавших студентов для каждого из предметов

`failed_subject(S, N).`- поиск количества студентов (N), не сдавших предмет S.

Примеры использования:
```
29 ?- failed_subject('Математический анализ', X).
X = 3.

30 ?- failed_subject('Психология', X).            
X = 1.

31 ?- failed_subject('Несуществующий предмет', X). 
X = 0.

32 ?- failed_subject('Психология', 2).
false.

33 ?- failed_subject('Психология', 1). 
true.
```

Реализация:
```
% failed_subject(subject, number_of_students_that_failed_subject_exam).
failed_subject(Subject, Number) :- findall(Student, grade(_, Student, Subject, 2), List), 
                                   length(List, Number).
```

При помощи предиката findall ищем список студентов, у которых по предмету Subject стоит оценка 2. Искомое количество - длина полученного списка.

* `print_failed_subject(Subj, Numb)` - выводит на экран список всех предметов и количество несдавших его студентов

Примеры использования:
```
9 ?- print_failed_subject(X, Y).
X = 'Английский язык',
Y = 4 ;
X = 'Информатика',
Y = 2 ;
X = 'Логическое программирование',
Y = 2 ;
X = 'Математический анализ',
Y = 3 ;
X = 'Психология',
Y = 1 ;
X = 'Функциональное программирование',
Y = 1.
```

Реализация:
```
% print subjects and number of students who failed it
print_failed_subject(Subject, Number) :- subjects(Subjects), member(Subject, Subjects), failed_subject(Subject, Number).
```

Вызываем функцию failed_subject для всех предметов из списка.

## Выводы

Списки в языке Пролог - это действительно необычная структура данных. Для обработки таких списков нужно использовать особые предикаты, которые чаще всего строятся рекурсивно. В рамках данной лабораторной работы были реализованы основные предикаты для обработки числовых и произвольных списков. На первый взгляд может показаться, что Прологовские списки очень неудобны для работы. Однако на самом деле это очень мощная встроенная структура данных, которая позволяет выполнять абсолютно все необходимые функции (стоит только реализовать их предикатами). Наверное, сложно представить себе более простую структуру данных на декларативных языках программирования.

На примере второго задания лабораторной работы можно убедиться, что списки могут использоваться и для создания реляционного представления предметной области. Таким образом, получается некая простая база данных, которую можно использовать для получения ответов на запросы. Однако стоит помнить и о неудобствах такого представления: большой расход памяти, ограниченный набор операций, сложность в выполнении рекурсивных запросов.

