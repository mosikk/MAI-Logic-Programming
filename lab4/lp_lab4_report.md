## Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Моисеенков И.П.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       5       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Обработка естественного языка - это общее направление искуственного интеллекта и математической лингвистики. В настоящее время для этого чаще всего применяются алгоритмы машинного обучения. Выделяют следующие методы обработки естественного языка: статистический (основан на подсчёте количества слов в тексте) и точный (основан на выделении информации из текста). Для упрощенного использования данных методов реализованы соответствующие библиотеки на всех популярных языках программирования.

Однако декларативные языки программирования (например, Prolog) тоже могут быть использованы для обработки естественных и искусственных языков. Поиск решения в Прологе осуществляется при помощи построения дерева, охватывающего все варианты ответа. Таким образом, если составить грамматику для обработки предложений и записать все грамматические правила в виде фактов и правил, то Пролог, перебирая все возможные варианты, сможет верно обработать переданную ему информацию.

## Задание

Реализовать разбор фраз языка, представляющих собой положительные и отрицательные высказывания. В результате предикат должен вывести все атомарные глубинные структуры.

Пример
```
? - decompose(["Саша", "любит", "игрушки", ",", "но", "не", "любит", "кубики", "и", "мячи"], X).

X = likes("Саша", "игрушки").
X = not_likes("Саша", "кубики").
X = not_likes("Саша", "мячи").

? - decompose(["Ира", "не", "любит", "стихи", "и", "прозы" ",", "а", "любит", "пьесы"], X).

X = not_likes("Ира", "стихи").
X = not_likes("Ира", "прозы").
X = likes("Ира", "пьесы").
```

## Принцип решения

Для решения данной задачи сначала необходимо построить грамматику для обработки русского языка:
```
VT = {слова из словаря, 'не'}

VN = {ФРАЗА, ДЕЙСТВИЯ, ГРУППА_ГЛАГОЛА, СУЩ, ГРУППА_ДОПОЛНЕНИЯ, РАЗДЕЛИТЕЛЬ}

S = ФРАЗА

P:

ФРАЗА -> СУЩ + ДЕЙСТВИЯ

ДЕЙСТВИЯ -> ГРУППА_ГЛАГОЛА | ГРУППА_ГЛАГОЛА + ДЕЙСТВИЯ

ГРУППА_ГЛАГОЛА -> ГЛАГОЛ + ГРУППА_ДОПОЛНЕНИЯ | РАЗДЕЛИТЕЛЬ + ГРУППА_ГЛАГОЛА | "НЕ" + ГРУППА_ГЛАГОЛА

ГРУППА_ДОПОЛНЕНИЯ -> СУЩ | ГРУППА_ДОПОЛНЕНИЯ + РАЗДЕЛИТЕЛЬ + ГРУППА_ДОПОЛНЕНИЯ

СУЩ -> "кубики" | "мячи" | ...

ГЛАГОЛ -> "любит" | ...

РАЗДЕЛИТЕЛЬ -> "и" | ", а" | ", но" | ","
```

Действиями я назвал часть предложения, включающую в себя все группы глаголов. В данной задаче к действиям можно отнести всё предложение за исключением первого слова - подлежащего.

Основная часть программного кода на Прологе - это описание составленной выше грамматики и составление словарей. Соответствующие фрагменты кода приведены ниже:

```
nouns(['игрушки', 'кубики', 'мячи', 'стихи', 'прозы', 'пьесы', 'Саша', 'Ира']).
verbs(['любит']).
separators([['и'], [',', 'но'], [',', 'а'], [',']]).

% checking nouns, verbs and separators: generating a dictionary and searching our word there
check_noun(Noun) :- nouns(List), member(Noun, List).
check_verb(Verb) :- verbs(List), member(Verb, List).
check_separator(Sep) :- separators(List), member(Sep, List).

% splitting a subject and actions
check_phrase([Subject | Actions], deep_st(Verb, Subject, Object)) :- check_noun(Subject), 
                                                                    check_actions(Actions, Verb, Object).

% actions -> verb_group
check_actions(Actions, Verb, Object) :- check_verb_group(Actions, Verb, Object).

% actions -> verb_group + actions
check_actions(Actions, Verb, Object) :- split(Actions, Verb_Group, TMP), check_verb_group(Verb_Group, Verb, Object), 
                                        check_actions(TMP, _, _).

check_actions(Actions, Verb, Object) :- split(Actions, TMP, Actions1), not(last_elem(TMP, 'не')), 
                                        check_verb_group(TMP, _, _),
                                        check_actions(Actions1, Verb, Object).

% verb_group -> 'НЕ' + verb_group
check_verb_group(['не' | Verb_Group], ['не' | Verb], Object) :- !, check_verb_group(Verb_Group, Verb, Object).

% verb_group -> verb + obj_group
check_verb_group([Verb | Object_Group], Verb, Object) :- check_verb(Verb),
                                                    check_object_group(Object_Group, Object).

% verb_group -> separator + verb_group
check_verb_group([Sep | Verb_Group], Verb, Object) :- check_separator([Sep]), 
                                                        check_verb_group(Verb_Group, Verb, Object).

check_verb_group([Sep1, Sep2 | Verb_Group], Verb, Object) :- check_separator([Sep1, Sep2]), 
                                                            check_verb_group(Verb_Group, Verb, Object).

% obj_group -> object
check_object_group([Object], Object) :- check_noun(Object).

% obj_group -> obj_group + separator + obj_group
check_object_group(Object_Group, Object) :- split(Object_Group, Object_Group1, Sep, TMP), length(Sep, 1), 
                                            check_separator(Sep), check_object_group(Object_Group1, Object),
                                            check_object_group(TMP, _).

check_object_group(Object_Group, Object) :- split(Object_Group, TMP, Sep, Object_Group2), length(Sep, 1),
                                        check_separator(Sep), check_object_group(TMP, _),
                                        check_object_group(Object_Group2, Object).
```

Словарь с разделителями представляет собой список списков. Это сделано с целью упрощения проверки "составных" разделителей, например ", но" или ", а".

При описании правила `НЕ + ГРУППА_ГЛАГОЛА` мной было использовано отсечение. Если Пролог сможет унифицировать найденную глагольную группу со структурой `НЕ + ГРУППА_ГЛАГОЛА`, то отсечение укажет Прологу на то, что не нужно пытаться унифицировать эту группу с остальными правилами обработки: это не даст результата и ускорит время работы программы.

Для упрощения написания кода я реализовал предикат split для разделения списка на 2 или 3 части.

```
% split a list into 2 or 3 parts
split(List, Part1, Part2) :- append(Part1, Part2, List), not(length(Part1, 0)), not(length(Part2, 0)).
split(List, Part1, Part2, Part3) :- append(Part1, TMP, List), append(Part2, Part3, TMP),
                                    not(length(Part1, 0)), not(length(Part2, 0)), not(length(Part3, 0)).
```

Для взаимодействия с пользователем используется предикат `decompose(Phrase, List)`. Данный предикат ищет все глубинные формы вида `deep_st(Verb, Subject, Object)` и собирает их в один список при помощи `setof`. Вспомогательный предикат `decompose_phrase(Phrase, Result)` обращается к грамматическим правилам для анализа поступившей фразы. Получая какую-либо глубинную структуру, он превращает её из вида `deep_st('любит', Subj, Obj)` в `likes(Subj, Obj)` при помощи оператора `=..`. Аналогично с отрицательными утверждениями.

```
% we contain deep structures in a set
decompose(Phrase, List) :- setof(Deep_st, decompose_phrase(Phrase, Deep_st), List).

decompose_phrase(Phrase, Result) :- check_phrase(Phrase, deep_st(Verb, Subject, Object)), 
                                    verb_to_term(Verb, Verb_Term), Result=..[Verb_Term, Subject, Object].
                                    
% generating a term's name for our verb
verb_to_term('любит', 'likes').
verb_to_term(['не' | 'любит'], 'not_likes').
```


## Результаты

```
2 ?- decompose(['Саша', 'любит', 'кубики', ',', 'но', 'не', 'любит', 'мячи', 'и', 'стихи'], X).
X = [likes('Саша', кубики), not_likes('Саша', мячи), not_likes('Саша', стихи)].

3 ?- decompose(['Ира', 'не', 'любит', 'стихи', 'и', 'прозы', ',', 'а', 'любит', 'пьесы' ], X).
X = [likes('Ира', пьесы), not_likes('Ира', прозы), not_likes('Ира', стихи)].

4 ?- decompose(['Саша', 'любит', 'кубики', 'и', 'игрушки', ',', 'но', 'не', 'любит', 'мячи', 'и', 'стихи',',', 'а', 'любит', 'прозы'], X). 
X = [likes('Саша', игрушки), likes('Саша', кубики), likes('Саша', прозы), not_likes('Саша', мячи), not_likes('Саша', стихи)].

5 ?- decompose(['Ира', 'любит', 'стихи', ',', 'любит', 'пьесы', ',', 'не', 'любит', 'игрушки'], X).
X = [likes('Ира', пьесы), likes('Ира', стихи), not_likes('Ира', игрушки)].
```

На всех тестах программа выдала верный ответ.

## Выводы

Изначально я считал, что логическое программирование не имеет ничего общего с обработкой текста. По моему мнению, это была задача, посильная исключительно алгоритмам искусственного интеллекта. Однако, при правильном подходе и Пролог можно научить обрабатывать текст.

Для обработки естественных языков необходимо составить грамматику, которая описывает все возможные терминальные и нетерминальные элементы, а также все возможные переходы между ними. Пролог, в свою очередь, при помощи построенной грамматики, унификации и бектрекинга сможет найти все сопоставления текста и нашей грамматики.

Выполняя данную лабораторную работу, я изучил способы построения грамматик для обработки арифметических выражений, русскоязычных предложений и поиска глубинных структур. Написанная мной программа может использоваться как маленькая часть какого-либо более масштабного проекта для обработки русскоязычных текстов.

При желании можно заставить Пролог понимать данный ему текст, но это очень долгая и кропотливая работа.

В заключение хотелось бы отметить, что Пролог может идеально подойти для обработки мелких текстов и выполнения простейших задач. Однако это возможно не самый лучший инструмент для решения данного типа задач.





