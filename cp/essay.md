# Реферат
## по курсу "Логическое программирование"

### студент: Моисеенков И. П.

## Нужно ли современным программистам изучать парадигму логического программирования?

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Немного предисловия

Если взглянуть на топ наиболее востребованных языков программирования (например IEEE Spectrum за 2019 год), то можно обнаружить, что наибольшей популярностью пользуются всеми известные объектно-ориентированные языки C++, Python, Java и C#. Если опуститься чуть пониже, то мы сможем найти парочку функциональных языков: Scala, Haskell. А вот Prolog, язык логического программирования, смог подняться только до 46-ой позиции топа (в котором, кстати говоря, всего 52 позиции). Я уже не говорю о менее известных декларативных языках, например Mercury и Oz - их в топе вообще нет. Неужели логическое программирование настолько бесполезное? Неужели декларативная семантика не нужна современным программистам? Давайте попробуем в этом разобраться.

## Введение

Прежде всего стоит объяснить, что же это такое - логическое программирование. Логическое программирование - это такой подход к написанию кода, при котором программа представляет собой совокупность правил и фактов без явного указания последовательности их применения. Взаимодействие с такими программами осуществляется через интерпретатор, который умеет отвечать на специальные запросы. Каждый запрос он сопоставляет (унифицирует) с теми фактами, что ввёл программист и, перебирая все возможные варианты, выводит все подходящие решения. Очень похоже на запросы к базам данных (о них мы, кстати, поговорим чуть позже).

Наиболее известный декларативный язык программирования - это конечно же Prolog (PROgramming in LOGic). Он полон по Тьюрингу, а значит любой Прологовский алгоритм можно реализовать на других, более удобных, полных по Тьюрингу языках (например, на тех же популярных C++ или Python). Однако для некоторых задач он всё же оказывается удобнее других языков (не зря же он получил "почётное" 46 место в топе).

## Для каких задач Prolog оказывается удобным?

### 1. Поиск решений

Остановимся чуть подробнее на том, как работает Пролог. Запрос сопоставляется с "головами" всех правил и фактов, имеющихся в программе. При удачном сопоставлении соответствующие переменные унифицируются, а Пролог продолжает аналогичным образом доказывать все утверждения в правой части найденного правила. При этом Пролог запоминает, какие переменные он уже смог унифицировать. Если в процессе доказательства встретится переменная, которая уже сопоставлена с каким-то значением, то она будет унифицирована с этим же значением. Если Пролог смог доказать все утверждения, то, ура, мы нашли ответ. В этом случае на экран выводятся все переменные из запроса вместе с сопоставленными им значениями.

Но что делать, если мы не смогли найти совпадение? Значит ли это, что у Пролога нет решения для этого запроса? Не совсем. Часто программы строятся таким образом, что один запрос можно сопоставить сразу с несколькими разными правилами. Это и попытается сделать Пролог. Если на каком-то этапе доказательства он не сможет найти соответствующее правило, то произойдёт откат (бэктрекинг). Пролог вернётся назад на один шаг и попытается унифицировать утверждение с каким-нибудь другим правилом. Кстати, бэктрекинг происходит и после нахождения решения. Таким образом, Прологом (почти) всегда будут рассмотрены и найдены все возможные решения для данного запроса.

По ходу работы логический интерпретатор строит дерево решений и выполняет его обход в глубину. А это как раз таки то, что нам надо! Обход в глубину используется для поиска путей в графах. Но если в императивных языках программирования придётся отдельно реализовывать алгоритмы для обхода, то в логических языках это всё уже есть. Можно воспользоваться схожестью механизмов поиска путей и поиска решений в Прологе.

Для реализации алгоритма поиска на Прологе придётся написать около пяти незамысловатых строчек кода и описать имеющийся граф. Дальше Пролог всё сделает сам. Итак, если вам быстро нужно решить задачу о нахождении пути, то логические языки - это то, что вам нужно. Стоит отметить, что на Прологе достаточно просто написать и алгоритм поиска в ширину, и алгоритм поиска с итерационным заглублением. Это может оказаться полезным, если необходимо найти в первую очередь кратчайший путь.

Пролог умеет искать не только пути, он также может найти решение какой-нибудь более сложной задачи. Если в задаче можно выделить некие состояния (вершины) и возможные переходы между ними (рёбра), то мы получим своеобразный граф. И если мы применим алгоритм поиска к пространству состояний, то сможем получить пошаговое решение задачи. Причём не одно решение, а все возможные! Вот один из примеров такой задачи:

```
Вдоль доски расположено 7 лунок, в которых лежат 3 белых и 3 чёрных шара. 
Передивинуть чёрные шары на место белых, а белые - на место чёрных. 
Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, 
находящуюся непосредственно за ближайшим шаром.
```

Но вряд ли кому-то придётся программировать решение выше описанной задачи, поэтому рассмотрим ещё один пример. Пусть состояния - все возможные расположения шашек на квадратном поле, а переходы - все возможные ходы. Тогда при помощи Прологовского поиска мы сможем получить алгоритм, который будет определять победные ходы для любой партии. При желании можно сделать алгоритм поиска и для других игр, которые не зависят от случайностей (например, шахматы).

### 2. Искусственный интеллект

Попробуем немного расширить описанный выше пример с шашками. Раз Пролог может находить ход для любого состояния, то пусть он попробует поиграть в шашки с реальным человеком. Вероятно, его ходы будут достаточно предсказуемы для игрока, но этого можно избежать, немного изменив алгоритм выбора следующего хода. Таким образом, мы создали искусственный интеллект на основе Пролога!

На самом деле, Пролог довольно часто применяется в области искусственного интеллекта. На Прологе можно написать рекомендательную систему, основанную на алгоритме k ближайших соседей, организовать экспертную систему и даже составить нейронную сеть! Но лучше всего он подойдёт для обработки естественно-языковых фраз.

Разберёмся, каким образом заставить Пролог обрабатывать произвольные запросы. Мы уже выяснили, что Прологу для работы нужен набор фактов и правил. Значит нужно как-то получить эти самые факты и правила. Тут к нам на помощь приходит составление грамматики. Порождающей грамматикой называется следующая четвёрка: `<VT, VN, S, P>`, где VT - словарь терминальных элементов, VN - словарь нетерминальных элементов, S -  начальный символ, а P - множество правил вывода, причём каждое правило должно приводить к цепочке, содержащей как минимум один терминальный элемент.

Для примера рассмотрим простейшую порождающую грамматику для обработки символьного математического выражения:
```
VT = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -, *, :}
VN = {число, выражение, терм}
S = выражение
P:
выражение -> терм ИЛИ выражение + терм ИЛИ выражение - терм
терм -> число ИЛИ терм * число ИЛИ терм : число
число -> 0 ИЛИ 1 ИЛИ 2 ИЛИ 3 ИЛИ ... ИЛИ 9...
```

Данной грамматикой мы формализовали все возможные высказывания. Осталось всего то перенести эту грамматику в Пролог. Для этого нужно реализовать словарь VT и правила P. И, вуаля, Пролог теперь умеет обрабатывать математические выражения. Плюс построения грамматики в том, что её довольно просто можно расширить. Если нам понадобилось обрабатывать, например, возведение в степень, то нужно всего лишь добавить один новый терминальный сивол и одно новое правило обработки выражения.

Несложно построить аналогичную грамматику и для русскоязычных запросов. В качестве нетерминальных символов можно взять группы членов предложений, в качестве терминальных - слова. Конечно, довольно непросто построить грамматику, которая смогла бы обработать все возможные русскоязычные высказывания. Поэтому Пролог удобен тогда, когда нужно уметь понимать ограниченный круг предложений.

Отмечу, что Пролог можно научить "понимать" естественно-языковые высказывания. Для этого придётся создать чуть больше словарей: словарь со всеми падежами существительных, словарь с пассивной и активной формами глагола и т.п. После этого Пролог сможет определять, что является действующим лицом в этой фразе, над чем совершается действие и т.д.

### 3. Доказательство теорем

Механизм доказательства утверждений может быть полезен математикам и для доказательства теорем. Для этого необходимо описать как можно больше известных фактов и задать соответствующий запрос Прологу. Если, используя обозначенные логические связи, Пролог-интерпретатору удалось найти решение, то заданное утверждение верно. При помощи техники метапрограммирования можно изменить механизм вывода ответа так, чтобы он показывал не только сам ответ, но и логическую цепочку переходов.

Пролог может быть полезен и программистам для анализа различных свойств алгоритмов. Например, реализовав какой-либо алгоритм на Прологе, можно доказать его корректность. Это может пригодиться при написании научных работ.

## Раскрываем весь потенциал логического программирования

Будем честны, описанные выше применения довольно специфичны. Далеко не каждый программист сталкивается с необходимостью обрабатывать естественно-языковые запросы, искать в простанстве состояний или доказывать какие-либо свойства. Значит ли это, что для таких программистов логическое программирование бесполезно?

Пора объявить одну из важнейших мыслей данного реферата. Логическое программирование - это не только Пролог. Мы регулярно встречаемся с декларативным подходом и за рамками этого языка. Рассмотрим, где ещё нам могут пригодиться знания логического программирования.

### Базы данных

Практически каждый программист имеет дело с базами данных. SQL - наиболее известный декларативный язык программирования, используемый для взаимодействия с базами данных. На самом деле SQL-запросы очень близки к запросам, передаваемым интерпретатору Prolog. SQL оперирует данными почти так же, как это делает Пролог. Оба языка одинаково умеют делать выводы из имеющихся фактов. Из всего этого можно сделать вывод о теоретической связи между Prolog и SQL. Почему теоретической? Потому что на практике их используют совершенно в разных сферах. Но тем не менее, понимание принципов логического программирования поможет познать архитектуру баз данных, понять механизмы их работы и научиться строить правильные запросы к ним.

### Makefile

Makefile - это файл, содержащий набор инструкций для автоматизации сборки проекта. Он будет полезен практически всем программистам на С/С++ на Unix-подобных операционных системах. Создавая мейкфайл, мы декларативно описываем зависимости и инструкции. Очень похоже на построение логических предикатов, не так ли? Знаете, какая самая главная проблема при написании мейкфайлов? Грамотное построение дерева зависимостей. Эту проблему как раз и решает логическое программирование. Человеку, освоившему эту парадигму, будет гораздо проще находить наиболее оптимальный и "красивый" (понятный) вариант построения зависимостей.

Кстати, логические языки очень хорошо подходят для генерации мейкфайлов.

### Разминка для мозгов

Программисты - это те люди, которым постоянно приходится думать: как реализовать алгоритм, как сделать его оптимальным, как избежать ошибок и т.д. Мозговая деятельность - это неотъемлемая часть их работы. Поэтому совершенствование мыслительных способностей будет очень полезно для программиста (как и для любого другого человека).

Постижение логического программирования - это как раз то, что поможет взглянуть на мир "под другим углом". Написание программ на традиционных императивных языках кардинально отличается от программирования на "декларативщине". Изучение данной парадигмы здорово развивает умение мыслить логически и поступательно.

## Нужно ли всё-таки изучать логическое программирование?

Да. Особенно важно изучить его тем программистам, которые интересуются искусственным интеллектом. Парадигма логического программирования не так сложна, как может показаться на первый взгляд. Программы на логических языках часто интуитивно понятны. Поэтому постижение этой парадигмы не займёт много времени. Но тем не менее, это даст свои плоды.

Как минимум, это положительно скажется на мозговой деятельности. Логическое программирование несомненно укрепит навык мыслить логически. Ну а помимо этого, декларативные языки могут пригодиться, если необходимо протестировать прототип или идею алгоритма, изучить его свойства. Можно использовать их и для быстрого решения какой-нибудь трудной задачи на поиск. Нельзя предугадать, с чем придётся столкнуться в жизни. Возможно в какой-то ситуации именно логическое программирование окажется "спасательным кругом".

Большей части программистов конечно вряд ли понадобится язык Пролог. Но навыки логического программирования могут вполне пригодиться.

## Список используемых источников
1. Топ языков программирования IEEE [Электронный ресурс]. URL: https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2019 (дата обращения 15.12.2020).
2. Сошников Д.В. Парадигма логического программирования. - М.: Вузовская книга, 2006. (дата обращения 16.12.2020)
3. Статья о логическом программировании [Электронный ресурс]. URL: https://habr.com/ru/post/322900/ (дата обращения 15.12.2020).
4. Статья о логическом программировании [Электронный ресурс]. URL: https://geekbrains.ru/posts/logic_programming (дата обращения 16.12.2020).
